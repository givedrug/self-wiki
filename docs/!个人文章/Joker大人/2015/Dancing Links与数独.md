
写这篇文章是为了介绍一个数独破解算法，在你看到真正的破解算法之前，我会做一个不短的铺垫，这应该对于真正理解算法的思想是重要的。

**一个容易忽视的链表技巧**

在处理双向链表的时候，删除一个节点$x$的操作是这样的：

$$L[R[x]]←L[x],R[L[x]]←R[x]$$

其中$L[x]$表示$x$的前驱节点，$R[x]$表示$x$的后继节点。

![](assets/Dancing%20Links与数独/2015041519.png)

但很少有人意识到还可以通过以下操作将$x$重新恢复到链表中：

$$L[R[x]]←x,R[L[x]]←x$$

一般情况下，我们不希望删除的节点还能重新链接回链表，不彻底的删除具有潜在的危险性。不过，评判一个操作的好坏取决于它的使用坏境，比如在回溯程序中，我们必须在某路径失败后，使程序回溯到原来的状态。

我们下面介绍的$DancingLinks$算法，正是通过这种手段还原的。

**精确覆盖问题**

$DancingLinks$正是为了解决一个这样的一般问题：给定一个$0,1$为元素的矩阵，能否找到一个行的集合，使得集合中每一列都恰好只包含一个$1$。

比如下面这个矩阵

$$\begin{matrix}0010110\\1001001\\0110010\\1001000\\0100001\\0001101\end{matrix}$$

就包含了这样一个行的集合（第$1$行，第$4$行，第$5$行）。

我们可以把所有列想象为全集的元素，把行想象为包含某些列元素的一个子集（或者行列换过来），那么问题就变成，寻找全集的一个划分。也即寻找一个子集的集合，使得每个元素都属于某一个子集，且仅属于那个子集。

显然这不是一个容易的问题，而且已经证明这是一个$NP-完全问题$【附录】，也是卡普的二十一个$NP-完全问题$之一。首选算法就是**回溯**了。

**$DancingLinks$算法**

现在正式介绍一下这个算法，$Knuth$称他为$X$算法，对于要处理的$0,1$矩阵$A$：

```
如果A为空，问题解决；返回成功。
否则，选择一个列c（确定的）。
选择一个使得A[r,c]=1的行r（非确定的）。
将r包含进部分解。
对于每一个使得A[r,j]=1的j，
	从A中删除列j，
	对于每一个使得A[i,j]=1的i，
		从A中删除行i。
在不断变小的A上，递归的重复上述算法。
```

算法在选取了不同的行$r$之后，裂变成不同的子算法，子算法之间是相互独立的；每一个子算法都包含一个当前的$A$矩阵，只是这个$A$矩阵根据行$r$进行了相应的删减。当列$c$只有$0$元素的时候，子算法返回失败。

自然的，这些子算法构成了一棵搜索树，第k层的每个子算法对应了选择的那$k$个不同的行。这个回溯算法使先序遍历了这棵树，也就是深度优先搜索。

对于任何选择列$c$的顺序，算法都可以得到所有解。但不同的选择顺序将使得搜索树的规模相去甚远。为了使搜索树获得最少的节点数目，每次都应该选择包含$1$最少的那个列$c$。$Knuth$的论文显示在一些较大规模的场景下，这样做会比随机选择搜索的节点数减少一个数量级。

好了，我们来看一下算法具体是怎么构建起来的，并且是怎么应用上那个“删除-恢复节点”的技巧的。

**Let's Dance**

将矩阵$A$中的每个元素$1$用一个具有五个域$L[x],R[x],U[x],D[x],C[x]$的数据对象$x$来表示。矩阵的每行都是一个环形的双向链表，通过$L$，$R$两个域连通（left and right）；每一列也是一个环形的双向链表，通过$U$，$D$两个域连通（up and down）。每一列还包含一个特殊的数据对象——列表头。

每个列表头都是一个更大一点的数据对象$y$。$y$包含七个域$L[y],R[y],U[y],D[y],C[y]$和另外两个增加的域$S[y]$（size）和$N[y]$（name）；$S[y]$表示的是这一列中元素1的个数，一方面为列的选择顺序提供依据，另一方面当值为0时返回失败。$N[y]$为这个列的名称，用于最后答案的输出。而以上所有对象中的域$C$都指向本列的列表头。

对于列表头通过$L$和$R$组成的环形双向链表，同样包含一个特殊的列表头对象$h$，可以把它当做整个数据结构的根。而且它的$U[h],D[h],C[h],S[h]$和$N[h]$是用不到的。

如果我们把上面那个$0,1$矩阵（列命名为$A、B、C、D、E、F、G$）作为例子用这些数据对象表示出来，就是下面这样：

![](assets/Dancing%20Links与数独/2015041501.png)

**注**：图中在上下左右处是相连的环形。而且没有画出$C$域，那样做会把图弄乱。列表头中标出的是列名和元素$1$的个数。

下面给出搜索过程$search(k)$的明晰的形式，当然在开始时，$k=0$：

```
if R[h]=h，输出当前解，返回成功。
else选择一个列c。
if c非空，Cover（c）。
else 返回失败。
for each r←D[c]，D[D[c]]，……，while r≠c，
	set Ok←r；
	for each j←R[r]，R[R[r]]，……，while j≠r，
		Cover(j)；
	search（k+1）；
	set r←Ok，c←C[r]；
	for each j←L[r]，L[L[r]]，……，while j≠r，
		Uncover（j）。
Uncover（c）返回失败。
```

1 输出当前解

很简单，我们已经得到了一个关于行的序列$O0，O1，O2，……，Ok-1$。最终我们需要的答案是一个行的集合，而这个序列中每一个对象对应某行中的一个元素$1$，而且我们知道，行与行之间没有重复，当得知这一行中哪些列元素值为1的时候，我们就可以唯一的确定这个行。所以只要输出$N[C[O]],N[C[R[O]]],N[C[R[R[O]]]]……$就代表了那一行，输出所有的$O$即为解。

2 选择一个列$c$

如果为了省事，可以简单的$set$ $c←R[h]$。

如果想获得最小分支的搜索树，可以

```
set s←正无穷
for each j←R[h]，R[R[h]]，……，while j≠h，
	if S[j]<s set c←j and s←S[j].
```

这样我们就得到了包含$1$最少的那一列$c$。

3 $Cover$操作

$Cover$操作是这样的，首先从列表头中删除$c$，然后遍历列$c$所有的对象，删除这些对象所在的行里面不是列$c$的那些对象。

```
set L[R[c]] ← L[c] and R[L[c]] ← R[c].
for each i ← D[c], D[D[c]], . . . , while I ≠ c,
	for each j ← R[i], R[R[i]], . . . , while j ≠ i,
		set U[D[j]] ← U[j], D[U[j]] ← D[j],
		and set S[C[j]] ← S[C[j]] − 1.
```

这就是我们在文章开头提到的删除节点的操作。

4 $Uncover$操作

这就是整个算法的重点了，也就是删除操作的逆操作。

```
for each i = U[c], U[U[c]], . . . , while i ≠ c,
	for each j ← L[i], L[L[i]], . . . , while j ≠ i,
		set S[C[j]] ← S[[j]] + 1,
		and set U[D[j]] ← j, D[U[j]] ← j.
set L[R[c]] ← c and R[L[c]] ← c.
```

注意到我们的还原操作和删除操作正好相反。操作时要非常小心。

是不是迫不及待的想知道算法是如何运行的了，下面将以前面的矩阵为例说明。

首先是$search(0)$选择一个最小列$A$，然后$Cover(A)$

![](assets/Dancing%20Links与数独/2015041502.png)

接下来选择$A$列中的某一行，首先选择的是第一行$(A,D,G)$，然后对这一行中**每一个**不在$A$列的对象所在的列进行$Cover$操作。如下图：

![](assets/Dancing%20Links与数独/2015041503.png)

接着程序进入$search(1)$，我们把矩阵中访问不到的列去掉，让图示更清晰。又是选择一个最小列$B$，然后$Cover(B)$

![](assets/Dancing%20Links与数独/2015041504.png)

因为列$B$只有一个对象，所以选择那一行$(B,C,F)$，然后进行一组$Cover$操作，得到下图：

![](assets/Dancing%20Links与数独/2015041505.png)

这样做完，我们就来到了$search(2)$，仍然将无法访问的列去掉，得到下图，这时发现只有列$E$，而且此列为空，说明本次搜索失败，返回。

![](assets/Dancing%20Links与数独/2015041506.png)

返回到$search(1)$，并且进行相应的$Uncover$操作，使删除操作得到还原。就还原到下面这张图，此时还在$search(1)$中。

![](assets/Dancing%20Links与数独/2015041507.png)

发现$B$列只有一行，已经完全遍历，于是$Uncover(A)$回溯到$search(0)$，下图：

![](assets/Dancing%20Links与数独/2015041508.png)

由于行$(A,D,G)$搜索失败，$for$循环将继续选择$A$列下一行$(A,D)$，跟着是一组$Cover$操作。

![](assets/Dancing%20Links与数独/2015041509.png)

这样我们就来到了另一个分支的$search(1)$，选择最小列$E$，$Cover(E)$.

![](assets/Dancing%20Links与数独/2015041510.png)

选择行$(C,E,F)$一组$Cover$操作后，得到：

![](assets/Dancing%20Links与数独/2015041511.png)

接着进入$search(2)$，选择$B$并$Cover(B)$:

![](assets/Dancing%20Links与数独/2015041512.png)

选择行$(B,G)$并进行一组$Cover$操作，得到：

![](assets/Dancing%20Links与数独/2015041513.png)

最终我们进入了$search(3)$，然后高兴的发现，$R[h]=h$，我们得到了一组解。

![](assets/Dancing%20Links与数独/2015041514.png)

输出$(A,D)(E,F,C)(B,G)$。

这样我们就使用$DancingLinks$算法将精确覆盖问题解决了。

**一个应用：骨牌拼图问题**

骨牌拼图问题是精确覆盖问题的一个经典应用，我们以$Scott$的$12$片$5$格骨牌问题为例：我们有$12$片骨牌，每片骨牌的大小都是$5$格，要求将这$12$片骨牌放入$8*8$的正方形棋盘中，而且棋盘中间留有一个边长为$2$的空格。比如下图就是其中的一个解

![](assets/Dancing%20Links与数独/2015041515.png)

可以将拼图问题转化为精确覆盖问题，我们想象有一个$72$列的矩阵，其中$60$列表示的是棋盘中非中心部分的格子，$12$列表示$12$片骨牌。矩阵的每一行表示一片骨牌在棋盘中的一种摆放方案，这一行中有$5$个$1$表示放置时压住的格子，还有一个$1$指示这是哪一片骨牌。如果你列举所有的摆放情况，你将得到$1568$个这样的行。

|      | r1c1 | r1c2 | r1c3 | r1c4 | r1c5 | r1c6 | ……  | r8c8 | 第1片 | 第2片 | ……  | 第12片 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --- | ---- | --- | --- | --- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0   | 0    | 1   | 0   | 0   | 0    |
| 2    |      |      |      |      |      |      |     |      |     |     |     |      |
| ……   |      |      |      |      |      |      |     |      |     |     |     |      |
| 1568 |      |      |      |      |      |      |     |      |     |     |     |      |

如果我们对“长条形”编号为第一片骨牌，那么表中第一行表示的就是它在下示位置时的情况。

![](assets/Dancing%20Links与数独/2015041516.jpg)

不难想象，精确覆盖编码之后的矩阵，我们就能得到问题的解。如果你有兴趣计算这个问题，将得到$65$组不同的拼图解。

**一种直观解释**

这一节，我将试图使用直观形象的解释去说明为什么$DancingLinks$执行之后，就能得到精确覆盖问题的解。这可能需要一点想象力。

首先我们回到骨牌问题，我们得到的那个矩阵到底意味着什么呢？想象在一个棋盘上，你拿着第一片骨牌“长条形”试图放置在棋盘里，为了获得放置的所有可能性，一种可选的方案是这么做，先选择一种姿态，比如横着，然后从棋盘的左上角开始，按着从左到右，从上到下的顺序依次摆放，直到棋盘的右下角停止，接着把他竖过来，仍然采用同样的方式，这样就得到了第一片骨牌的所有可能位置。当你把所有骨牌的位置都得到之后，就得到了那个$1568$行的矩阵，这时你可以认为有$1568$片骨牌，叠加在那个棋盘上。

下面的所有操作都是在这个有着$1568$片骨牌的棋盘上进行的，认识到这一点很重要。

我们选择一个列$c$然后$Cover(c)$是什么意思呢？因为一列指代的是棋盘上某一个格子，选择一列即选择那个格子，$Cover(c)$实际上是把所有覆盖到这一个格子的骨牌全部拿走（这里的拿走是说，你通过其他格子上的骨牌，再也无法访问到这个格子）。

接着我们选择了列$c$中的某一行，进行了一组$Cover$操作，这又代表什么呢？正如之前所说，选择列$c$的某一行，其实就是在拿走的那些骨牌里面挑一片，然后把这一片压住的格子上面的全部骨牌都拿走，并且使得这些格子在之后都不能被访问。“挑一片”意思是，我先认定挑出来的这一片是正确的，如果这样认为，当然要将和我这一片有交集的其他骨牌全部丢弃才不会发生冲突，因为一个格子只能有一个骨牌。

就这样迭代的选取，直到两种情况下程序可以给出判断，一种是恰好所有的格子都无法访问，这就说明本次挑选的骨牌序列恰好铺满了整个棋盘，于是得到一组解；另一种情况是，程序选取到某一个仍然可以访问的格子时，发现上面已经没有骨牌了，这就说明，这次挑选的骨牌序列不足以铺满整个棋盘，而且也没有合适的骨牌恰好填补这个格子了，这时就会返回失败。

返回失败后，程序将回溯到上一次$search$的位置，然后在那一打骨牌里面挑选下一片运行，就这样反复试错，直到把所有可能性全部囊括进来。

不知道我的解释是不是让问题更清楚了呢？

**数独问题转化为精确覆盖问题**

假设我们现在已经完全理解了什么是精确覆盖问题，也知道了$DancingLinks$算法的含义，那么如果一个问题恰好可以转换为精确覆盖问题，只要给出转换方案，我们就可以求解了，数独问题正好就是这类问题。

数独：在一个$99$格子的盘面上，又被分为$3*3$个宫，每宫有$3*3$个格子，格子上会给出已知的数字$1-9$，要求根据这些数字，推理出所有剩余格子的数字，并满足每一行、每一列、每一宫内的数字均含$1-9$，不重复。

一个数独谜题：

![](assets/Dancing%20Links与数独/2015041517.png)

上面数独的解：

![](assets/Dancing%20Links与数独/2015041518.png)

实际上一个数独的规则可以总结为以下四条：

> $1$ 每个格子有一个数字
> 
> $2$ 每行$1-9$分别填一遍
> 
> $3$ 每列$1-9$分别填一遍
> 
> $4$ 每宫$1-9$分别填一遍
> 

下面只需将这些约束规则转换为矩阵的列定义即可：

对于$规则1$定义如下各列：

格$(1,1)$有一个数字；

格$(1,2)$有一个数字；

……

格$(9,9)$有一个数字；

共计$81$列

对于$规则2$定义如下各列：

第$1$行填了数字$1$

第$1$行填了数字$2$

……

第$9$行填了数字$9$

共计$81$列

对于$规则3$定义如下各列：

第$1$列填了数字$1$

第$1$列填了数字$2$

……

第$9$列填了数字$9$

共计$81$列

对于$规则4$定义如下各列：

第$1$宫填了数字$1$

第$1$宫填了数字$2$

……

第$9$宫填了数字$9$

共计$81$列

因此矩阵共包含$324$列。

那么如何将一个给定的数独问题，转换为一个具体的矩阵呢？对于数独中的格子，要分两种情况，有数字或没有数字。

**有数字的格子**

比如第$1$宫里的格$(3,2)$填了数字$9$，对应规则得到：

$1$ 格$(3,2)$有一个数字

$2$ 第$3$行填了数字$9$

$3$ 第$2$列填了数字$9$

$4$ 第$1$宫填了数字$9$

所以“第$1$宫里的格$(3,2)$填了数字$9$”对应的行中，只需将上述四列设置为$1$，其余列设置为$0$。

**没有数字的格子**

比如第$2$宫格$(1,4)$数字待填，可以转换为：

第$2$宫格$(1,4)$填了数字$1$

第$2$宫格$(1,4)$填了数字$2$

……

第$2$宫格$(1,4)$填了数字$9$

分别按照有数字的格子的转换方法计算，就能得到矩阵的$9$行。

至此，这样就能把数独问题转化为精确覆盖问题了。

**$Knuth$**

$DancingLinks$算法正是由$Knuth$发明，他将其归功于$Hiroshi Hitotsumatsu$与$Kōhei Noshita$在$1979$的研究，但是$Knuth$的论文让$DancingLinks$流行。算法的巧妙无需多言。

之所以将其命名为$DancingLinks$是因为$Knuth$觉得，算法不断的进行删除和还原的操作，节点的“打开”和“关闭”演奏出一串跳动的音符，好似一位灵动的舞者随之起舞。

**参考**

1  Dancing Links. Donald E. Knuth, Stanford University 2000.11

2 算法实践——舞蹈链（Dancing Links）算法求解数独[http://www.cnblogs.com/grenet/p/3163550.html](http://www.cnblogs.com/grenet/p/3163550.html)

3 数独[http://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8](http://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8)

4 舞蹈链[http://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88%E9%93%BE](http://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88%E9%93%BE)

5 卡普的二十一个NP-完全问题[http://zh.wikipedia.org/wiki/%E5%8D%A1%E6%99%AE%E7%9A%84%E4%BA%8C%E5%8D%81%E4%B8%80%E5%80%8BNP-%E5%AE%8C%E5%85%A8%E5%95%8F%E9%A1%8C](http://zh.wikipedia.org/wiki/%E5%8D%A1%E6%99%AE%E7%9A%84%E4%BA%8C%E5%8D%81%E4%B8%80%E5%80%8BNP-%E5%AE%8C%E5%85%A8%E5%95%8F%E9%A1%8C)

**附录：卡普的21个NP完全问题**

1.	布尔可满足性问题（Satisfiability）：对于布尔逻辑内合取范式方程式的满足性问题（一般直接叫做SAT）
2.	0-1 整数规划（0-1 integer programming）
3.	分团问题（Clique）（参考独立集）
4.	Set packing(Set packing)
5.	最小顶点覆盖问题（Vertex cover）
6.	集合覆盖问题(Set covering)
7.	Feedback node set（Feedback node set）
8.	Feedback arc set
9.	有向哈密顿循环 (卡普命名，现称Directed Hamiltonian cycle)
10.	无向哈密顿循环 (卡普命名，现称Undirected Hamiltonian cycle)
11.	每句话至多3个变量的布尔可满足性问题 (Satisfiability with at most 3 literals per clause, 3-SAT)
12.	图着色问题（Chromatic number）
13.	分团覆盖问题（Clique cover）
14.	精确覆盖问题（Exact cover）
15.	Hitting set（Hitting set）
16.	Steiner tree（Steiner tree）
17.	三维匹配问题（3-dimensional matching）
18.	背包问题（Knapsack）
19.	Job sequencing（Job sequencing）
20.	划分问题（Partition）
21.	最大割（Max cut）

2015-04-15
