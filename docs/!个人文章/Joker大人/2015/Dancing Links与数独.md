
写这篇文章是为了介绍一个数独破解算法，在你看到真正的破解算法之前，我会做一个不短的铺垫，这应该对于真正理解算法的思想是重要的。

**一个容易忽视的链表技巧**

在处理双向链表的时候，删除一个节点x的操作是这样的：

$$L[R[x]]←L[x],R[L[x]]←R[x]$$

其中$L[x]$表示$x$的前驱节点，$R[x]$表示$x$的后继节点。

但很少有人意识到还可以通过以下操作将x重新恢复到链表中：

$$L[R[x]]←x,R[L[x]]←x$$

一般情况下，我们不希望删除的节点还能重新链接回链表，不彻底的删除具有潜在的危险性。不过，评判一个操作的好坏取决于它的使用坏境，比如在回溯程序中，我们必须在某路径失败后，使程序回溯到原来的状态。

我们下面介绍的DancingLinks算法，正是通过这种手段还原的。

**精确覆盖问题**

DancingLinks正是为了解决一个这样的一般问题：给定一个$0,1$为元素的矩阵，能否找到一个行的集合，使得集合中每一列都恰好只包含一个$1$。

比如下面这个矩阵

$$\begin{matrix}0010110\\1001001\\0110010\\1001000\\0100001\\0001101\end{matrix}$$

就包含了这样一个行的集合（第$1$行，第$4$行，第$5$行）。

我们可以把所有列想象为全集的元素，把行想象为包含某些列元素的一个子集（或者行列换过来），那么问题就变成，寻找全集的一个划分。也即寻找一个子集的集合，使得每个元素都属于某一个子集，且仅属于那个子集。

显然这不是一个容易的问题，而且已经证明这是一个NP-完全问题【附录】，也是卡普的二十一个NP-完全问题之一。首选算法就是**回溯**了。

**DancingLinks算法**

现在正式介绍一下这个算法，Knuth称他为$X$算法，对于要处理的$0,1$矩阵$A$：

```
如果A为空，问题解决；返回成功。
否则，选择一个列c（确定的）。
选择一个使得A[r,c]=1的行r（非确定的）。
将r包含进部分解。
对于每一个使得A[r,j]=1的j，
	从A中删除列j，
	对于每一个使得A[i,j]=1的i，
		从A中删除行i。
在不断变小的A上，递归的重复上述算法。
```

算法在选取了不同的行$r$之后，裂变成不同的子算法，子算法之间是相互独立的；每一个子算法都包含一个当前的$A$矩阵，只是这个$A$矩阵根据行$r$进行了相应的删减。当列$c$只有$0$元素的时候，子算法返回失败。

自然的，这些子算法构成了一棵搜索树，第k层的每个子算法对应了选择的那$k$个不同的行。这个回溯算法使先序遍历了这棵树，也就是深度优先搜索。

对于任何选择列$c$的顺序，算法都可以得到所有解。但不同的选择顺序将使得搜索树的规模相去甚远。为了使搜索树获得最少的节点数目，每次都应该选择包含$1$最少的那个列$c$。Knuth的论文显示在一些较大规模的场景下，这样做会比随机选择搜索的节点数减少一个数量级。

好了，我们来看一下算法具体是怎么构建起来的，并且是怎么应用上那个“删除-恢复节点”的技巧的。

**Let's Dance**

将矩阵$A$中的每个元素$1$用一个具有五个域$L[x],R[x],U[x],D[x],C[x]$的数据对象$x$来表示。矩阵的每行都是一个环形的双向链表，通过$L$，$R$两个域连通（left and right）；每一列也是一个环形的双向链表，通过$U$，$D$两个域连通（up and down）。每一列还包含一个特殊的数据对象——列表头。

每个列表头都是一个更大一点的数据对象$y$。$y$包含七个域$L[y],R[y],U[y],D[y],C[y]$和另外两个增加的域$S[y]$（size）和$N[y]$（name）；$S[y]$表示的是这一列中元素1的个数，一方面为列的选择顺序提供依据，另一方面当值为0时返回失败。$N[y]$为这个列的名称，用于最后答案的输出。而以上所有对象中的域$C$都指向本列的列表头。

对于列表头通过$L$和$R$组成的环形双向链表，同样包含一个特殊的列表头对象$h$，可以把它当做整个数据结构的根。而且它的$U[h],D[h],C[h],S[h]$和$N[h]$是用不到的。

如果我们把上面那个$0,1$矩阵（列命名为$A、B、C、D、E、F、G$）作为例子用这些数据对象表示出来，就是下面这样：

![](assets/Dancing%20Links与数独/2015041501.png)

**注**：图中在上下左右处是相连的环形。而且没有画出$C$域，那样做会把图弄乱。列表头中标出的是列名和元素$1$的个数。

下面给出搜索过程$search(k)$的明晰的形式，当然在开始时，$k=0$：

```
If R[h]=h，输出当前解，返回成功。
Else选择一个列c。
If c非空，Cover（c）。
Else 返回失败。
For each r←D[c]，D[D[c]]，……，while r≠c，
	Set Ok←r；
	For each j←R[r]，R[R[r]]，……，while j≠r，
		Cover(j)；
	Search（k+1）；
	Set r←Ok，c←C[r]；
	For each j←L[r]，L[L[r]]，……，while j≠r，
		Uncover（j）。
Uncover（c）返回失败。
```

1. 输出当前解

很简单，我们已经得到了一个关于行的序列$O0，O1，O2，……，Ok-1$。最终我们需要的答案是一个行的集合，而这个序列中每一个对象对应某行中的一个元素$1$，而且我们知道，行与行之间没有重复，当得知这一行中哪些列元素值为1的时候，我们就可以唯一的确定这个行。所以只要输出$N[C[O]],N[C[R[O]]],N[C[R[R[O]]]]……$就代表了那一行，输出所有的$O$即为解。

2. 选择一个列$c$

如果为了省事，可以简单的$Set c←R[h]$。

如果想获得最小分支的搜索树，可以



![](assets/Dancing%20Links与数独/2015041502.png)

![](assets/Dancing%20Links与数独/2015041503.png)

![](assets/Dancing%20Links与数独/2015041504.png)

![](assets/Dancing%20Links与数独/2015041505.png)

![](assets/Dancing%20Links与数独/2015041506.png)

![](assets/Dancing%20Links与数独/2015041507.png)

![](assets/Dancing%20Links与数独/2015041508.png)

![](assets/Dancing%20Links与数独/2015041509.png)

![](assets/Dancing%20Links与数独/2015041510.png)

![](assets/Dancing%20Links与数独/2015041511.png)

![](assets/Dancing%20Links与数独/2015041512.png)

![](assets/Dancing%20Links与数独/2015041513.png)

![](assets/Dancing%20Links与数独/2015041514.png)

![](assets/Dancing%20Links与数独/2015041515.png)

![](assets/Dancing%20Links与数独/2015041516.jpg)

![](assets/Dancing%20Links与数独/2015041517.png)

![](assets/Dancing%20Links与数独/2015041518.png)

![](assets/Dancing%20Links与数独/2015041519.png)